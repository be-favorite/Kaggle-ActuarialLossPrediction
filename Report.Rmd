---
title: "<center> **<font size = 5> {tidymodels}를 이용한 보상 보험금 청구액 예측 **</font> </center>"
author: "방태모"
date: "`r Sys.Date()`"
output: 
  rmdformats::robobook
---
<style>
.math {
  font-size: small;
}
</style>

## **0 Before start**
***
이 자료는 [제 깃허브 저장소](https://github.com/be-favorite/Kaggle-ActuarialLossPrediction)로부터 제공됩니다. 대회 및 자료에 대한 자세한 사항은 저장소 메인의 README.md를 참고해주세요.`r emo::ji("blush")`

## **1 Preparing**
***
### 1.1 패키지 불러오기
```{r}
library(tidymodels)
```

```{r}
library(vroom)
library(corrplot)
ggplot2::theme_set(theme_light())
loaded_package <- c("vroom", "corrplot")
.version <- map(loaded_package, packageVersion)
names(.version) <- loaded_package
.version
```

### 1.2 자료 불러오기
```{r, message = FALSE}
claim_train <- vroom("./data/train.csv")
```

```{r, message = FALSE}
claim_test <- vroom("./data/test.csv")
```

분석에 이용할 자료는 훈련 자료(training data, $n = 54,000$), 시험 자료(test data, $n = 36,000$)를 합쳐 총 90,000명의 근로자의 보상 보험에 대한 정보를 담고있다. 각 변수에 대한 자세한 설명은 다음과 같다:

- ClaimNumber: 고유 청구 번호
- DataTimeOfAccident: 사고 발생 날짜 및 시간
- DateReported: 사고가 보고된 날짜
- Age: 근로자의 나이
- Gender: 근로자의 성별
- MaritalStatus: 근로자의 결혼여부
  + (M)arried: 기혼
  + (S)ingle: 미혼
  + (U)nkown: 알 수 없음
- DependentChildren: 부양 자녀의 수
- DependentsOther: 자녀 외 부양 가족의 수
- WeeklyWages: 주급
- PartTimeFullTime: 파트타임, 풀타임 여부를 나타내는 이진형 변수
  + (P): 파트타임
  + (F): 풀타임
- HoursWorkedPerWeek: 주당 노동 시간
- DaysWorkedPerWeek: 주당 노동 일 수
- ClaimDescription: 보상 청구에 관한 설명
- IntiallncurredClaimCost: 보험업자가 추정한 초기 청구비용
- UltimateIncurredClaimCost($y$): 보험 회사가 지급한 총 보험금. 즉, 우리가 시험자료에 대한 예측이 필요한 부분

## **2 EDA**
***
이제 모델링 작업에 앞서 EDA 작업을 수행한다. 먼저, 훈련자료와 시험자료를 결합해준다.
```{r}
claim <- bind_rows(claim_train, claim_test) %>% 
  rowid_to_column
glimpse(claim)
```

다음으로 변수별 기초통계량을 확인해보자.

```{r}
summary(claim)
```
그리고, 변수별 결측치 존재 유무를 확인해보았다. 다음의 결과는 결측치가 하나라도 존재하는 변수에 해당한다:
```{r}
map(claim, is.na) %>% 
  map_dfr(sum) %>% 
  pivot_longer(everything(), names_to = "variables", values_to = "count") %>% 
  filter(count > 0)
```

우리가 시험자료에서 추정해야 할 보험 회사가 지급한 총 보험금(`UltimateIncurredClaimCost`, $y$)의 결측치 갯수는 시험자료의 행의 수와 정확하게 일치하므로 문제가 없으나, 결혼여부를 나타내는 변수 `MritalStatus`의 경우는 검토가 필요하다고 할 수 있다.

```{r}
claim %>% 
  select(MaritalStatus) %>% 
  unique
```

해당 변수에 결측을 갖는 관측치들을 검토해보자.
```{r}
claim %>% 
  filter(is.na(MaritalStatus)) %>% 
  select(rowid, MaritalStatus, DependentChildren, DependentsOther, everything())
```

결혼 여부가 결측인 관측치들의 부양 자녀 수와 자녀를 제외한 부양 가족 수는 모두 0에 해당하며,
`rowid`로 확인할 수 있듯이, 훈련 자료와 시험 자료에 모두 존재하고 있다. 그래서, 꼭 해당 변수의 결측에 대한 대치 또는 결혼 여부 변수 제거 작업이 필요할 것으로 예상된다. 우선 결혼 여부에 따른 부양 자녀 또는 자녀를 제외한 부양 가족 수에 대한 평균을 구해보았다.
```{r}
claim %>% 
  group_by(MaritalStatus) %>% 
  summarise(
    mean_child = mean(DependentChildren),
    mean_other = mean(DependentsOther)
  )
```

꼭 결혼여부가 미혼(S) 이나 알수없음(U)이라 해서 부양 자녀 또는 자녀를 제외한 부양 가족이 없는 것은 아니다. 일단 결혼여부에 결측을 갖는 관측치에 관한 조사는 이쯤하고 넘어가도록 하자. 90,000개 관측치 중 47개(0.05%)에 불과하기도 하고, 결혼 여부가 꼭 $y$와 관련이 있을 지는 모르기 때문이다. 

이러한 점은 상관행렬의 시각화를 통해 확인해볼 수 있다. 다음의 상관계수 행렬은 보험 회사가 지급한 총 보험금(`UltimateIncurredClaimCost`, $y$) 열의 상관계수의 절댓값을 기준으로 내림차순 정렬하여 그린 것이다. 다만, $y$가 결측으로 주어지는 시험자료의 관측치와 행번호(`rowid`), 고유청구번호(`ClaimNumber`), 사고 발생 날짜 및 시각(`DateTimeOfAccident`), 사고가 보고된 날짜(`DateReported`) 열을 제외하였다. 그리고, 문자열로 읽혀있는 범주형 변수들을 모두 factor화 시켜주었으며, 상관계수를 구하기 위해 수치형 변수로 변환을 해주었다.

```{r, fig.align = "center", out.width = "60%", cache = TRUE}
claim %>% 
  filter(!is.na(UltimateIncurredClaimCost), !is.na(MaritalStatus)) %>% 
  select(Age:UltimateIncurredClaimCost, -ClaimDescription) %>% 
  mutate(across(is.character, as.factor)) %>% 
  mutate_if(is.factor, as.numeric) %>% 
  cor %>% 
  {.[order(abs(.[, "UltimateIncurredClaimCost"]), decreasing = TRUE),
     order(abs(.[, "UltimateIncurredClaimCost"]), decreasing = TRUE)]} %>% 
  corrplot(method = "number", type = "upper", 
           mar = c(0, 0, 1.5, 0), tl.col = "black")
```

$X$들 중에 $y$와 선형적인 상관성은 거의 미약하고, 초기 청구비용에 관한 변수(`IntiallncurredClaimCost`)만이 약간의 양의 상관을 보이고 있다고 할 수 있다. 아울러, 결혼 여부는 거의 선형적 관계가 아예 없어보인다. 그럼 우선 결혼 여부에 관한 변수에서 결측을 갖는 관측치의 경우 "알수없음(U)"으로 대치하고 모델링을 진행하자.
```{r}
claim_train2 <- claim_train %>% 
  select(Age:UltimateIncurredClaimCost, -ClaimDescription) %>% 
  mutate(MaritalStatus = factor(ifelse(is.na(MaritalStatus), "U", MaritalStatus)))
claim_test2 <- claim_test %>% 
  select(Age:InitialIncurredCalimsCost, -ClaimDescription) %>% 
  mutate(MaritalStatus = factor(ifelse(is.na(MaritalStatus), "U", MaritalStatus)))
```


## **3 Modelling**
***
먼저 {recipes}를 이용해 모형 적합 전 필요한 전처리를 수행한다. 혹시, {tidymodels} 패키지에 익숙하지 않다면, [여기](https://github.com/be-favorite/Tutorial_tidymodels)를 참고해주세요. 
```{r}
cla_rec <- recipe(UltimateIncurredClaimCost ~ ., data = claim_train2) %>% 
  step_normalize(all_predictors(), -all_nominal()) %>% 
  step_dummy(all_nominal())
```

본 연구에서는 랜덤포레스트 모형을 적합해볼 것이며, 먼저 모수 튜닝을 위해 자료를 3-fold로 나눠줍니다.
```{r}
set.seed(1)
cla_vfold <- vfold_cv(claim_train2, v = 3, strata = UltimateIncurredClaimCost)
```


다음으로 튜닝을 위한 모형 객체를 준비할 것이며, 본 모형 적합에 조정할 초 모수는 랜덤포레스트의 모형 형성 시 매 트리 적합에 고려할 변수들의 개수를 조정하는 `mtry`입니다. 
```{r}
rf_model <- rand_forest(mtry = tune()) %>% 
  set_mode("regression") %>% 
  set_engine("ranger")
```

다음 모형에서 저희가 고려할 수 있는 $X$의 수는 다음과 같이 [1, 13]으로 고려할 `mtry`의 범위는 추후 워크플로 객체에서 지정하겠습니다:
```{r}
rf_model %>% 
  parameters() %>% 
  finalize(x = juice(prep(cla_rec)) %>% select(-UltimateIncurredClaimCost)) %>% 
  pull("object")
```

다음으로 `workflow()`를 이용해 recipe 객체와 모형 객체를 결합해 줍니다.
```{r}
rf_wflow <- workflow() %>% 
  add_model(rf_model) %>% 
  add_recipe(cla_rec)
rf_wflow
```

다음으로는 `mtry`의 범위를 지정해줍니다. 본 모형 적합에서는 매 트리 적합시 최소 3개, 최대 10개의 변수를 고려해보려고 합니다.
```{r}
rf_param <- rf_wflow %>% 
  parameters() %>% 
  update(mtry = mtry(range = c(3L, 10L)))
rf_param %>% pull("object")
```

이정도 초모수 조합은 grid search로도 충분하므로, 해당 모수 조합의 grid를 만듭니다.
```{r}
rf_grid <- grid_regular(rf_param, levels = 8)
rf_grid
```

병렬 처리를 위한 설정을 해줍니다.
```{r, message = FALSE}
library(doFuture)
all_cores <- parallel::detectCores(logical = FALSE) - 1
registerDoFuture()
cl <- parallel::makeCluster(all_cores)
plan(future::cluster, workers = cl)
```

이제 튜닝을 시작합니다.`r emo::ji("blush")`
```{r, warning = FALSE, cache = TRUE}
options(future.rng.onMisue = "ignore")
rf_search <- tune_grid(rf_wflow, grid = rf_grid, resamples = cla_vfold,
                       param_info = rf_param)
```


```{r}
autoplot(rf_search, metric = "rmse")
```

## **4 Prediction **
이제 최종 예측을 수행하고 글을 마무리 하겠습니다. 

```{r, cache = TRUE}
rf_param_final <- select_best(rf_search, metric = "rmse")
rf_wflow_final <- finalize_workflow(rf_wflow, rf_param_final)
rf_wflow_final_fit <- fit(rf_wflow_final, data = claim_train2)
```

```{r}
cla_rec2 <- pull_workflow_prepped_recipe(rf_wflow_final_fit)
rf_final_fit <- pull_workflow_fit(rf_wflow_final_fit)

claim_test2$.pred <- predict(rf_final_fit,
                             new_data = bake(cla_rec2, claim_test2)) %>% pull(.pred)

```

```{r}
claim_test2 %>% 
  mutate(ClaimNumber = claim_test %>% pull(ClaimNumber)) %>% 
  select(ClaimNumber, .pred) %>% 
  rename(UltimateIncurredClaimCost = .pred) %>% 
  vroom_write("./submission/submission_1.csv", delim = ",")
```

분석을 러프하게 진행하고 마지막으로 예측 작업까지 해보았습니다. 아직 완성된 글이 아니니 조금만 기다려 주세요.`r emo::ji("sweat")` 부지런히 업데이트 하겠습니다.